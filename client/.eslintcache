[{"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/index.js":"1","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/App.js":"2","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/serviceWorker.js":"3","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Login.js":"4","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Signup.js":"5","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/OrderHistory.js":"6","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Success.js":"7","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Home.js":"8","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Detail.js":"9","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/NoMatch.js":"10","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/GlobalState.js":"11","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/Nav/index.js":"12","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/mutations.js":"13","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/auth.js":"14","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/queries.js":"15","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/actions.js":"16","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/reducers.js":"17","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/helpers.js":"18","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/Jumbotron/index.js":"19","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/CategoryMenu/index.js":"20","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/Cart/index.js":"21","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/ProductList/index.js":"22","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/CartItem/index.js":"23","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/ProductItem/index.js":"24","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/store.js":"25"},{"size":704,"mtime":1610732812692,"results":"26","hashOfConfig":"27"},{"size":2047,"mtime":1610732873357,"results":"28","hashOfConfig":"27"},{"size":5080,"mtime":1610478331540,"results":"29","hashOfConfig":"27"},{"size":1953,"mtime":1610478331537,"results":"30","hashOfConfig":"27"},{"size":2445,"mtime":1610478331539,"results":"31","hashOfConfig":"27"},{"size":1455,"mtime":1610478331538,"results":"32","hashOfConfig":"27"},{"size":1082,"mtime":1610478331539,"results":"33","hashOfConfig":"27"},{"size":907,"mtime":1610478331536,"results":"34","hashOfConfig":"27"},{"size":7280,"mtime":1610732374785,"results":"35","hashOfConfig":"27"},{"size":371,"mtime":1610478331537,"results":"36","hashOfConfig":"27"},{"size":3803,"mtime":1610730113849,"results":"37","hashOfConfig":"27"},{"size":1280,"mtime":1610478331531,"results":"38","hashOfConfig":"27"},{"size":773,"mtime":1610478331544,"results":"39","hashOfConfig":"27"},{"size":1015,"mtime":1610478331543,"results":"40","hashOfConfig":"27"},{"size":905,"mtime":1610478331544,"results":"41","hashOfConfig":"27"},{"size":1592,"mtime":1610478331542,"results":"42","hashOfConfig":"27"},{"size":2443,"mtime":1610735918602,"results":"43","hashOfConfig":"27"},{"size":4768,"mtime":1610478331543,"results":"44","hashOfConfig":"27"},{"size":234,"mtime":1610478331530,"results":"45","hashOfConfig":"27"},{"size":3514,"mtime":1610737526895,"results":"46","hashOfConfig":"27"},{"size":4541,"mtime":1610735386868,"results":"47","hashOfConfig":"27"},{"size":3781,"mtime":1610735632360,"results":"48","hashOfConfig":"27"},{"size":3325,"mtime":1610732283797,"results":"49","hashOfConfig":"27"},{"size":1816,"mtime":1610732307272,"results":"50","hashOfConfig":"27"},{"size":389,"mtime":1610733633350,"results":"51","hashOfConfig":"27"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},"qsufjn",{"filePath":"55","messages":"56","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"54"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"54"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"78"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"97","messages":"98","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"54"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"54"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"105","usedDeprecatedRules":"54"},{"filePath":"106","messages":"107","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"108","usedDeprecatedRules":"54"},{"filePath":"109","messages":"110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/index.js",[],["111","112"],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/App.js",["113"],"import React from \"react\";\n// import ReactDOM from 'react-dom';\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\nimport { ApolloProvider } from '@apollo/react-hooks';\nimport ApolloClient from 'apollo-boost';\n\nimport Home from \"./pages/Home\";\nimport Detail from \"./pages/Detail\";\nimport NoMatch from \"./pages/NoMatch\";\nimport Login from \"./pages/Login\";\nimport Signup from \"./pages/Signup\";\nimport Nav from \"./components/Nav\";\n// import { StoreProvider } from \"./utils/GlobalState\";\nimport OrderHistory from \"./pages/OrderHistory\";\nimport Success from \"./pages/Success\";\n\nimport { Provider } from 'react-redux';\nimport store from './utils/store'\n\nconst client = new ApolloClient({\n  request: (operation) => {\n    const token = localStorage.getItem('id_token')\n    operation.setContext({\n      headers: {\n        authorization: token ? `Bearer ${token}` : ''\n      }\n    })\n  },\n  uri: '/graphql',\n})\n\nfunction App() {\n  return (\n    <ApolloProvider client={client}>\n      <Router>\n        <div>\n          {/* <Provider store={store}> */}\n            <Nav />\n           <div className=\"container\">{JSON.stringify(store.getState())}\n              <Switch>\n                <Route exact path=\"/\" component={Home} />\n                <Route exact path=\"/login\" component={Login} />\n                <Route exact path=\"/signup\" component={Signup} />\n                <Route exact path=\"/orderHistory\" component={OrderHistory} />\n                <Route exact path=\"/products/:id\" component={Detail} />\n                <Route exact path=\"/success\" component={Success} />\n                <Route component={NoMatch} />\n              </Switch>\n           </div>\n          {/* </Provider> */}\n        </div>\n      </Router>\n    </ApolloProvider>\n  );\n}\n// Did you notice how we use the <StoreProvider> to wrap all of our components? Everything between those JSX tags are considered the children of <StoreProvider>; that's why it was so important that we had ...props in the definition of our StoreProvider function!\n\nexport default App;\n","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/serviceWorker.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Login.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Signup.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/OrderHistory.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Success.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Home.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/Detail.js",["114"],"import React, { useEffect, useState } from \"react\";\nimport { idbPromise } from \"../utils/helpers\";\n// import { useStoreContext } from \"../utils/GlobalState\";\nimport { Provider } from 'react-redux';\nimport store from '../utils/store'\nimport {\n  REMOVE_FROM_CART,\n  UPDATE_CART_QUANTITY,\n  ADD_TO_CART,\n  UPDATE_PRODUCTS,\n} from \"../utils/actions\";\nimport { Link, useParams } from \"react-router-dom\";\nimport { useQuery } from \"@apollo/react-hooks\";\n\nimport { QUERY_PRODUCTS } from \"../utils/queries\";\nimport spinner from \"../assets/spinner.gif\";\nimport Cart from \"../components/Cart\";\n\nfunction Detail() {\n  // const { id } = useParams();\n\n  // const [currentProduct, setCurrentProduct] = useState({})\n\n  // const { loading, data } = useQuery(QUERY_PRODUCTS);\n\n  // const products = data?.products || [];\n\n  // useEffect(() => {\n  //   if (products.length) {\n  //     setCurrentProduct(products.find(product => product._id === id));\n  //   }\n  // }, [products, id]);\n  const [state, dispatch] = store;\n  const { id } = useParams();\n\n  const [currentProduct, setCurrentProduct] = useState({});\n\n  const { loading, data } = useQuery(QUERY_PRODUCTS);\n\n  // const { products } = state;\n  const { products, cart } = state;\n\n  useEffect(() => {\n    // already in global store\n    if (products.length) {\n      setCurrentProduct(products.find(product => product._id === id));\n    } \n    // retrieved from server\n    else if (data) {\n      dispatch({\n        type: UPDATE_PRODUCTS,\n        products: data.products\n      });\n  \n      data.products.forEach((product) => {\n        idbPromise('products', 'put', product);\n      });\n    }\n    // get cache from idb\n    else if (!loading) {\n      idbPromise('products', 'get').then((indexedProducts) => {\n        dispatch({\n          type: UPDATE_PRODUCTS,\n          products: indexedProducts\n        });\n      });\n    }\n  }, [products, data, loading, dispatch, id]);\n  \n\n  // const addToCart = () => {\n  //   dispatch({\n  //     type: ADD_TO_CART,\n  //     product: { ...currentProduct, purchaseQuantity: 1 }\n  //   });\n  // };\n  const addToCart = () => {\n    const itemInCart = cart.find((cartItem) => cartItem._id === id)\n  \n    if (itemInCart) {\n      dispatch({\n        type: UPDATE_CART_QUANTITY,\n        _id: id,\n        purchaseQuantity: parseInt(itemInCart.purchaseQuantity) + 1\n      });\n      // if we're updating quantity, use existing item data and increment purchaseQuantity value by one\n      idbPromise('cart', 'put', {\n        ...itemInCart,\n        purchaseQuantity: parseInt(itemInCart.purchaseQuantity) + 1\n      });\n    } else {\n      dispatch({\n        type: ADD_TO_CART,\n        product: { ...currentProduct, purchaseQuantity: 1 }\n      });\n      // if product isn't in the cart yet, add it to the current shopping cart in IndexedDB\n      idbPromise('cart', 'put', { ...currentProduct, purchaseQuantity: 1 });\n    }\n  }\n  \n\n  const removeFromCart = () => {\n    dispatch({\n      type: REMOVE_FROM_CART,\n      _id: currentProduct._id\n    });\n  \n    // upon removal from cart, delete the item from IndexedDB using the `currentProduct._id` to locate what to remove\n    idbPromise('cart', 'delete', { ...currentProduct });\n  };\n\n  return (\n    <>\n      {currentProduct ? (\n        <div className=\"container my-1\">\n          <Link to=\"/\">← Back to Products</Link>\n\n          <h2>{currentProduct.name}</h2>\n\n          <p>{currentProduct.description}</p>\n\n          <p>\n            <strong>Price:</strong>${currentProduct.price}{\" \"}\n            <button onClick={addToCart}>Add to cart</button>\n            <button\n              disabled={!cart.find((p) => p._id === currentProduct._id)}\n              onClick={removeFromCart}\n            >\n              Remove from Cart\n            </button>\n          </p>\n\n          <img\n            src={`/images/${currentProduct.image}`}\n            alt={currentProduct.name}\n          />\n        </div>\n      ) : null}\n      {loading ? <img src={spinner} alt=\"loading\" /> : null}\n      <Cart />\n    </>\n  );\n}\n\nexport default Detail;\n\n// So again, we go through all of the motions of getting the global state, querying data using Apollo and destructuring the products out of state. But what's going one with the useEffect() Hook? And why do we still have local state? Why isn't the currentProduct part of the global state?\n\n// To answer the first question, the useEffect() Hook here has to check for a couple of things. It first checks to see if there's data in our global state's products array. If there is, we use it to figure out which product is the current one that we want to display. It does this finding the one with the matching _id value that we grabbed from the useParams() Hook. But what happens if we don't have any products in our global state object? What happens if someone just sent you this product's URL and this is the first time you've loaded this application?\n\n// If that's the case, then you wouldn't have any products saved in global state just yet. The useEffect() Hook is set up so that if we don't, we'll use the product data that we returned from the useQuery() Hook to set the product data to the global state object. When that's complete, we run through this all over again. But this time, there is data in the products array, and then we run setCurrentProduct() to display a single product's data.\n\n// This is why there are so many items in the second argument of the useEffect() Hook. The Hook's functionality is dependent on them to work and only runs when it detects that they've changed in value! This is known as the dependency array.\n\n// It's a lot of back and forth, but it works! But what about our second question? Why are we saving the current product locally and not to the global state?\n\n// This is one of those cases where saving a single product to the global state object doesn't actually benefit us in any way, shape, or form. The single product's data will only be used in this specific component at this specific moment. This is the same reason why we don't worry about saving form entry data from the login or signup forms to global state; it only needs to exist when we're using those components!\n\n// Okay, now we'll update the useEffect() Hook to check if we have data returning from a global state and stored in products. Then we'll account for the following possibilities:\n\n// If yes, let's get the current product and save it to the local state currentProduct.\n\n// If no, we don't have data in global state, let's check whether we retrieved data from the server using the useQuery() Hook. If yes, save that data to global state and to the product object store in IndexedDB, and we'll run the useEffect() Hook over again to make that first if statement run.\n\n// If no, we don't have data in global state and we don't have a connection to the server, the loading data will be undefined. We'll then go to the product object store in IndexedDB and retrieve the data from there to provide the global state object.\n\n// If this seems like a lot, remember that you'll be making fantastic use of the useEffect() Hook React provides. It will constantly check the dependency array for a change in any of the values listed in it and continue to run the useEffect() Hook's callback function until that data stops changing and you're good to go.\n\n\n","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/pages/NoMatch.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/GlobalState.js",["115","116","117"],"import React, { createContext, useContext } from \"react\";\n// import { useProductReducer } from \"./reducers\";\n// createContext will be used to instantiate a new Context object. The more meaningful term we can use here is that we're using it to create the container to hold our global state data and functionality so we can provide it throughout our app!\n\n// useContext is another React Hook that will allow us to use the state created from the createContext function.\n\nconst StoreContext = createContext();\nconst { Provider } = StoreContext;\n// Every Context object comes with two components, a Provider and Consumer. The Provider is a special type of React component that we wrap our application in so it can make the state data that's passed into it as a prop available to all other components. The Consumer is our means of grabbing and using the data that the Provider holds for us.\n\n// const StoreProvider = ({ value = [], ...props }) => {\n//   const [state, dispatch] = useProductReducer({\n//     products: [],\n//     cart: [],\n//     cartOpen: false,\n//     categories: [],\n//     currentCategory: \"\",\n//   });\n//   // use this to confirm it works!\n//   console.log(state);\n//   return <Provider value={[state, dispatch]} {...props} />;\n// };\n// With this function, StoreProvider, we instantiate our initial global state with the useProductReducer() function we created earlier. Because that wraps it around the useReducer() Hook from React, every time we run this useProductReducer() function, we receive the following two items in return:\n\n// state is the most up-to-date version of our global state object.\n\n// dispatch is the method we execute to update our state. It is specifically going to look for an action object passed in as its argument, as we'll soon see.\n\n// After the useProductReducer() completes and provides us with the new state and function to update state (e.g., dispatch), we then return the StoreContext's <Provider> component with our state object and dispatch the function provided as data for the value prop.\n\n// With all of this in place, the StoreProvider function isn't as much of a function as it is our own custom <Provider> component! That's why the parameters defined at the top, the value and ...props, are there. It's actually set up to accept props if it needs to, and it does!\n\n// The value prop is good to have included, as it opens us up to pass in more data for state if we need to. We don't actually need to in this app, but it makes this provider flexible. The other prop, or rather ...props, is in place to handle any other props the user may need. Namely, we'll need to use props.children, as this <StoreProvider> component will wrap all of our other components, making them children of it. If we didn't include {...props} in our returning <Provider> component, nothing on the page would be rendered!\n\n// This is a lot to take in, and it takes some developers years to grasp it and put it to use. But in short, what we did here was create our own functionality to manage state at a global level and make it available to all of our other components through a special <Provider> component. The last thing we need to do is create the custom function using the useContext() Hook to be used by the components that actually need the data our <StoreProvider> will be, well . . . providing!\n\nconst useStoreContext = () => {\n  return useContext(StoreContext);\n};\n// We just created our own custom React Hook! When we execute this function from within a component, we will receive the [state, dispatch] data our StoreProvider provider manages for us. This means that any component that has access to our StoreProvider component can use any data in our global state container or update it using the dispatch function.\n\n// export { StoreProvider, useStoreContext };\n",["118","119"],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/Nav/index.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/mutations.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/auth.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/queries.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/actions.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/reducers.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/helpers.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/Jumbotron/index.js",[],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/CategoryMenu/index.js",["120","121"],"/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/Cart/index.js",["122","123"],"import React, { useEffect } from \"react\";\nimport { TOGGLE_CART, ADD_MULTIPLE_TO_CART } from \"../../utils/actions\";\nimport { idbPromise } from \"../../utils/helpers\";\nimport CartItem from \"../CartItem\";\nimport Auth from \"../../utils/auth\";\n// import { useStoreContext } from \"../../utils/GlobalState\";\nimport { Provider } from 'react-redux';\nimport store from '../../utils/store'\nimport \"./style.css\";\nimport { QUERY_CHECKOUT } from \"../../utils/queries\";\nimport { loadStripe } from \"@stripe/stripe-js\";\nimport { useLazyQuery } from '@apollo/react-hooks';\n\nconst stripePromise = loadStripe(\"pk_test_TYooMQauvdEDq54NiTphI7jx\");\n\nconst Cart = () => {\n  // const [state, dispatch] = store;\n  const [getCheckout, { data }] = useLazyQuery(QUERY_CHECKOUT);\n\nconst state = store.getState();\n\n  useEffect(() => {\n    async function getCart() {\n      const cart = await idbPromise(\"cart\", \"get\");\n      store.dispatch({ type: ADD_MULTIPLE_TO_CART, products: [...cart] });\n    }\n\n    if (!state.cart.length) {\n      getCart();\n    }\n  }, [state.cart.length, store.dispatch]);\n  // You may wonder what happens if there's nothing to retrieve from the cached object store and state.cart.length is still 0. Does this useEffect() function just continuously run because of that? Well, it could very easily do that if we neglect to pass the state.cart.length value into useEffect()'s dependency array. That's the whole point of the dependency array. We list all of the data that this useEffect() Hook is dependent on to execute. The Hook runs on load no matter what, but then it only runs again if any value in the dependency array has changed since the last time it ran.\n  useEffect(() => {\n    if (data) {\n      stripePromise.then((res) => {\n        res.redirectToCheckout({ sessionId: data.checkout.session });\n      });\n    }\n  }, [data]);\n  // The Stripe documentation warns that you shouldn't rely on the success_url alone for fulfilling purchases. Malicious users could visit /success directly without paying for anything, or users might close the browser tab before Stripe is able to redirect to your website. Implementing a more robust solution is beyond the scope of this lesson, but it's worth reading over Stripe's documentation on confirming a successful payment to see what else is possible.\n\n  function toggleCart() {\n    store.dispatch({ type: TOGGLE_CART });\n  }\n  if (!state.cartOpen) {\n    return (\n      <div className=\"cart-closed\" onClick={toggleCart}>\n        <span role=\"img\" aria-label=\"trash\">\n          🛒\n        </span>\n      </div>\n    );\n  }\n\n  function calculateTotal() {\n    let sum = 0;\n    state.cart.forEach((item) => {\n      sum += item.price * item.purchaseQuantity;\n    });\n    return sum.toFixed(2);\n  }\n\n  console.log(state);\n\n  function submitCheckout() {\n    const productIds = [];\n  \n    state.cart.forEach((item) => {\n      for (let i = 0; i < item.purchaseQuantity; i++) {\n        productIds.push(item._id);\n      }\n      getCheckout({\n        variables: { products: productIds }\n      });      \n    });\n  }\n  // Unfortunately, we can't call useQuery(QUERY_CHECKOUT) in the click handler function. The useQuery Hook is meant to run when a component is first rendered, not at a later point in time based on a user action like a button click. Apollo provides another Hook for this exact situation. The useLazyQuery Hook can be declared like any other Hook but won't actually execute until you tell it to. Let's implement this new Hook to call QUERY_CHECKOUT.\n  \n  //       // You should always wrap emojis (like the shopping cart icon) in a <span> element that includes role and aria-label attributes. Doing so will help screen readers understand the context of the emoji.\n  return (\n    <div className=\"cart\">\n      <div className=\"close\" onClick={toggleCart}>\n        [close]\n      </div>\n      <h2>Shopping Cart</h2>\n      {state.cart.length ? (\n        <div>\n          {state.cart.map((item) => (\n            <CartItem key={item._id} item={item} />\n          ))}\n          <div className=\"flex-row space-between\">\n            <strong>Total: ${calculateTotal()}</strong>\n            {Auth.loggedIn() ? (\n              <button onClick={submitCheckout}>Checkout</button>\n            ) : (\n              <span>(log in to check out)</span>\n            )}\n          </div>\n        </div>\n      ) : (\n        <h3>\n          <span role=\"img\" aria-label=\"shocked\">\n            😱\n          </span>\n          You haven't added anything to your cart yet!\n        </h3>\n      )}\n    </div>\n  );\n};\n\nexport default Cart;\n","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/ProductList/index.js",["124","125"],"import React, { useEffect } from 'react';\nimport { idbPromise } from \"../../utils/helpers\";\n// import { useStoreContext } from '../../utils/GlobalState';\nimport { Provider } from 'react-redux';\nimport store from '../../utils/store'\nimport { UPDATE_PRODUCTS } from '../../utils/actions';\nimport { useQuery } from '@apollo/react-hooks';\n\nimport ProductItem from \"../ProductItem\";\nimport { QUERY_PRODUCTS } from \"../../utils/queries\";\nimport spinner from \"../../assets/spinner.gif\"\n\n\n\nfunction ProductList() {\n// function ProductList({ currentCategory }) {\n//   const { loading, data } = useQuery(QUERY_PRODUCTS);\n\n//   const products = data?.products || [];\n\n//   function filterProducts() {\n//     if (!currentCategory) {\n//       return products;\n//     }\n\n//     return products.filter(product => product.category._id === currentCategory);\n//   }\n\nconsole.log('Initial state: ', store.getState())\n\n// const [state, dispatch] = store.getState();\nconst state = store.getState();\n\nconst { currentCategory } = state;\n\nconst { loading, data } = useQuery(QUERY_PRODUCTS);\n\n// store.dispatch({type: UPDATE_PRODUCTS, payload: data.products})\n\nuseEffect(() => {\n  // if there's data to be stored\n  if (data) {\n    // let's store it in the global state object\n    store.dispatch({\n      type: UPDATE_PRODUCTS,\n      products: data.products\n    });\n\n    // but let's also take each product and save it to IndexedDB using the helper function \n    data.products.forEach((product) => {\n      idbPromise('products', 'put', product);\n    });\n      // add else if to check if `loading` is undefined in `useQuery()` Hook\n    } else if (!loading) {\n      // since we're offline, get all of the data from the `products` store\n      idbPromise('products', 'get').then((products) => {\n        // use retrieved data to set global state for offline browsing\n        store.dispatch({\n          type: UPDATE_PRODUCTS,\n          products: products\n        });\n      });\n    }\n  }, [data, loading, store.dispatch]);\n\nfunction filterProducts() {\n  if (!currentCategory) {\n    return state.products;\n  }\n\n  return state.products.filter(product => product.category._id === currentCategory);\n}\n\n  return (\n    <div className=\"my-2\">\n      <h2>Our Products:</h2>\n      {state.products.length ? (\n        <div className=\"flex-row\">\n            {filterProducts().map(product => (\n                <ProductItem\n                  key= {product._id}\n                  _id={product._id}\n                  image={product.image}\n                  name={product.name}\n                  price={product.price}\n                  quantity={product.quantity}\n                />\n            ))}\n        </div>\n      ) : (\n        <h3>You haven't added any products yet!</h3>\n      )}\n      { loading ? \n      <img src={spinner} alt=\"loading\" />: null}\n    </div>\n  );\n}\n\nexport default ProductList;\n\n// Again, we immediately execute the useStoreContext() function to retrieve the current global state object and the dipatch() method to update state. We then destructure the currentCategory data out of the state object so we can use it in the filterProducts() function.\n\n// We then implement the useEffect() Hook in order to wait for our useQuery() response to come in. Once the data object returned from useQuery() goes from undefined to having an actual value, we execute our dispatch() function, instructing our reducer function that it's the UPDATE_PRODUCTS action and it should save the array of product data to our global store. When that's done, useStoreContext() executes again, giving us the product data needed display products to the page.\n\n// Lastly, we need to update the code in the return statement to use state.products.length instead of products.length, since we are now retrieving products from the state object","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/CartItem/index.js",["126"],"import React from \"react\";\nimport { idbPromise } from \"../../utils/helpers\";\n// import { useStoreContext } from \"../../utils/GlobalState\";\nimport { Provider } from 'react-redux';\nimport store from '../../utils/store'\nimport { REMOVE_FROM_CART, UPDATE_CART_QUANTITY } from \"../../utils/actions\";\n\nconst CartItem = ({ item }) => {\n  const [, dispatch] = store;\n  // This component currently gets all of its data as props passed down from Cart. That won't change, but now CartItem will also update the global state to adjust item quantities. Note that we only destructured the dispatch() function from the useStoreContext Hook, because the CartItem component has no need to read state.\n  const removeFromCart = item => {\n    dispatch({\n      type: REMOVE_FROM_CART,\n      _id: item._id\n    });\n    idbPromise('cart', 'delete', { ...item });\n  };\n\n  const onChange = (e) => {\n    const value = e.target.value;\n\n    if (value === '0') {\n      dispatch({\n        type: REMOVE_FROM_CART,\n        _id: item._id\n      });\n    \n      idbPromise('cart', 'delete', { ...item });\n    } else {\n      dispatch({\n        type: UPDATE_CART_QUANTITY,\n        _id: item._id,\n        purchaseQuantity: parseInt(value)\n      });\n    \n      idbPromise('cart', 'put', { ...item, purchaseQuantity: parseInt(value) });\n    }\n  };\n\n  return (\n    <div className=\"flex-row\">\n      <div>\n        <img src={`/images/${item.image}`} alt=\"\" />\n      </div>\n      <div>\n        <div>\n          {item.name}, ${item.price}\n        </div>\n        <div>\n          <input\n            type=\"number\"\n            placeholder=\"1\"\n            value={item.purchaseQuantity}\n            onChange={onChange}\n            />\n            {/* This will also clear up the error that React was throwing earlier, because the onChange handler means that the value of this element can now potentially change and is no longer read-only. Test this out in the browser by adding an item to the cart and then typing a new number in the <input> element. Doing so will automatically update the total dollar amount, because the parent Cart component re-renders whenever the global state is updated. */}\n          <span\n            role=\"img\"\n            aria-label=\"trash\"\n            onClick={() => removeFromCart(item)}\n          >\n            🗑️\n          </span>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CartItem;\n\n// 0.chunk.js:45521 Warning: Failed prop type: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\n//     in input (at CartItem/index.js:16)\n//     in div (at CartItem/index.js:14)\n//     in div (at CartItem/index.js:12)\n//     in div (at CartItem/index.js:5)\n//     in CartItem (at Cart/index.js:42)\n//     in div (at Cart/index.js:40)\n//     in div (at Cart/index.js:36)\n//     in Cart (at Detail.js:109)\n//     in Detail (created by Context.Consumer)\n//     in Route (at App.js:39)\n//     in Switch (at App.js:34)\n//     in StoreProvider (at App.js:32)\n//     in div (at App.js:31)\n//     in Router (created by BrowserRouter)\n//     in BrowserRouter (at App.js:30)\n//     in ApolloProvider (at App.js:29)\n//     in App (at src/index.js:9)\n//     in StrictMode (at src/index.js:8)\n","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/components/ProductItem/index.js",["127"],"import React from \"react\";\nimport { idbPromise } from \"../../utils/helpers\";\nimport { Link } from \"react-router-dom\";\nimport { pluralize } from \"../../utils/helpers\";\n// import { useStoreContext } from \"../../utils/GlobalState\";\nimport { Provider } from 'react-redux';\nimport store from '../../utils/store'\nimport { ADD_TO_CART, UPDATE_CART_QUANTITY } from \"../../utils/actions\";\n\nfunction ProductItem(item) {\n  const [state, dispatch] = store;\n\n  const { image, name, _id, price, quantity } = item;\n\n  // const addToCart = () => {\n  //   dispatch({\n  //     type: ADD_TO_CART,\n  //     product: { ...item, purchaseQuantity: 1 }\n  //   });\n  // };\n\n  const { cart } = state;\n\n  const addToCart = () => {\n    // find the cart item with the matching id\n    const itemInCart = cart.find((cartItem) => cartItem._id === _id);\n\n    // if there was a match, call UPDATE with a new purchase quantity\n    if (itemInCart) {\n      dispatch({\n        type: UPDATE_CART_QUANTITY,\n        _id: _id,\n        purchaseQuantity: parseInt(itemInCart.purchaseQuantity) + 1,\n      });\n      idbPromise(\"cart\", \"put\", {\n        ...itemInCart,\n        purchaseQuantity: parseInt(itemInCart.purchaseQuantity) + 1,\n      });\n    } else {\n      dispatch({\n        type: ADD_TO_CART,\n        product: { ...item, purchaseQuantity: 1 },\n      });\n      idbPromise(\"cart\", \"put\", { ...item, purchaseQuantity: 1 });\n    }\n  };\n\n  return (\n    <div className=\"card px-1 py-1\">\n      <Link to={`/products/${_id}`}>\n        <img alt={name} src={`/images/${image}`} />\n        <p>{name}</p>\n      </Link>\n      <div>\n        <div>\n          {quantity} {pluralize(\"item\", quantity)} in stock\n        </div>\n        <span>${price}</span>\n      </div>\n      <button onClick={addToCart}>Add to cart</button>\n    </div>\n  );\n}\n\nexport default ProductItem;\n","/Users/jwj/Desktop/Desktop-Folders/projects/shop-shop-redux/client/src/utils/store.js",[],{"ruleId":"128","replacedBy":"129"},{"ruleId":"130","replacedBy":"131"},{"ruleId":"132","severity":1,"message":"133","line":17,"column":10,"nodeType":"134","messageId":"135","endLine":17,"endColumn":18},{"ruleId":"132","severity":1,"message":"133","line":4,"column":10,"nodeType":"134","messageId":"135","endLine":4,"endColumn":18},{"ruleId":"132","severity":1,"message":"136","line":1,"column":8,"nodeType":"134","messageId":"135","endLine":1,"endColumn":13},{"ruleId":"132","severity":1,"message":"137","line":8,"column":9,"nodeType":"134","messageId":"135","endLine":8,"endColumn":17},{"ruleId":"132","severity":1,"message":"138","line":37,"column":7,"nodeType":"134","messageId":"135","endLine":37,"endColumn":22},{"ruleId":"128","replacedBy":"139"},{"ruleId":"130","replacedBy":"140"},{"ruleId":"132","severity":1,"message":"133","line":5,"column":10,"nodeType":"134","messageId":"135","endLine":5,"endColumn":18},{"ruleId":"141","severity":1,"message":"142","line":45,"column":6,"nodeType":"143","endLine":45,"endColumn":45,"suggestions":"144"},{"ruleId":"132","severity":1,"message":"133","line":7,"column":10,"nodeType":"134","messageId":"135","endLine":7,"endColumn":18},{"ruleId":"141","severity":1,"message":"142","line":31,"column":6,"nodeType":"143","endLine":31,"endColumn":41,"suggestions":"145"},{"ruleId":"132","severity":1,"message":"133","line":4,"column":10,"nodeType":"134","messageId":"135","endLine":4,"endColumn":18},{"ruleId":"141","severity":1,"message":"142","line":64,"column":6,"nodeType":"143","endLine":64,"endColumn":37,"suggestions":"146"},{"ruleId":"132","severity":1,"message":"133","line":4,"column":10,"nodeType":"134","messageId":"135","endLine":4,"endColumn":18},{"ruleId":"132","severity":1,"message":"133","line":6,"column":10,"nodeType":"134","messageId":"135","endLine":6,"endColumn":18},"no-native-reassign",["147"],"no-negated-in-lhs",["148"],"no-unused-vars","'Provider' is defined but never used.","Identifier","unusedVar","'React' is defined but never used.","'Provider' is assigned a value but never used.","'useStoreContext' is assigned a value but never used.",["147"],["148"],"react-hooks/exhaustive-deps","React Hook useEffect has an unnecessary dependency: 'store.dispatch'. Either exclude it or remove the dependency array. Outer scope values like 'store.dispatch' aren't valid dependencies because mutating them doesn't re-render the component.","ArrayExpression",["149"],["150"],["151"],"no-global-assign","no-unsafe-negation",{"desc":"152","fix":"153"},{"desc":"154","fix":"155"},{"desc":"156","fix":"157"},"Update the dependencies array to be: [categoryData, loading]",{"range":"158","text":"159"},"Update the dependencies array to be: [state.cart.length]",{"range":"160","text":"161"},"Update the dependencies array to be: [data, loading]",{"range":"162","text":"163"},[1905,1944],"[categoryData, loading]",[1026,1061],"[state.cart.length]",[1955,1986],"[data, loading]"]